# 贪吃蛇
## 参与对象
* 舞台
* 蛇
* 食物
* 墙
### 舞台创建
用canvas创建舞台，舞台实际就是个矩阵，这边我们创建了以`20px*20px`一个格子的`20*20`的矩阵。

```
    <canvas id="can" width="400" height="400" style="background-color: black">对不起，您的浏览器不支持canvas</canvas>
```

一共是20*20的400个格子，也就是0~399。
### 蛇
用绿色格子表示，用一个一维数组存放，记作`snake`。
如何绘制一个格子所在位置：`fillRect(seat % 20 * 20 + 1, parseInt(seat / 20) * 20 + 1, 18, 18)`;
### 食物
用黄色格子表示。
### 
## 活动
* 投食
* 蛇的活动
### 投食方法
从0~399中产生一个随机数，投放到对应的坐标上。
### 蛇的活动
* 前进
* 吃食
* 死亡(碰到自己、撞墙)
### 前进
通过对数组的头的添加(`unshift()`)和尾的旧节点的删除(`pop()`)实现移动。
移动方向记作direction，上下左右：`-20,20,-1,1`。因为向上或者向下动一格位置都是一行20格的叠加，左右都是一格。
键盘操作：上下左右键，对应的keyword值：← 37, ↑ 38, → 39, ↓ 40。
添加键盘敲击事件的监听，以便对方向进行处理。要行进的direction的计算：`[-1, -20 , 1, 20][(evt || event).keyCode -37]`，原先的direction： `snake[1] - snake[0]`.
### 吃食
当下一次头出现的位置和食物的位置相同时，就代表吃到食物了。吃到食物的蛇不用去蛇尾。
### 死亡
 #### 碰到自己
 下一次头出现的位置(n), 如果下次头出现的位置和蛇身有重合，那么就是碰到自己了，我们可以通过`indexOf()`来查找，从去除蛇头的位置开始查找，`snake.indexOf(n, 1)`,如果结果大于0，就是找到了，也就是碰到了自己，游戏结束。
 #### 撞墙
向上方向移动撞墙：`n < 0`。
向下方向移动撞墙：`n > 399`。
向左方向移动撞墙：`direction === -1  && n % 20 === 19`。
向右方向移动撞墙：`direction === 1  && n % 20 === 0`。
